// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb/mail.proto

package pb // import "mail-server/pb"

import (
	fmt "fmt"
	"io"

	proto "github.com/gogo/protobuf/proto"

	math "math"

	context "golang.org/x/net/context"

	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 邮件头是邮件是摘要信息，比较小。邮件列表返回的是邮件头。
// 服务器对邮件头中的数据是按请求原样保存，不会更改其中内容。
type MailHeader struct {
	From                 []byte                        `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	FromNick             []byte                        `protobuf:"bytes,2,opt,name=from_nick,json=fromNick,proto3" json:"from_nick,omitempty"`
	To                   []byte                        `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	ToNick               []byte                        `protobuf:"bytes,4,opt,name=to_nick,json=toNick,proto3" json:"to_nick,omitempty"`
	Title                []byte                        `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
	Brief                []byte                        `protobuf:"bytes,6,opt,name=brief,proto3" json:"brief,omitempty"`
	BodyLen              uint32                        `protobuf:"varint,7,opt,name=body_len,json=bodyLen,proto3" json:"body_len,omitempty"`
	Attachments          []*MailHeader_AttachmentBrief `protobuf:"bytes,8,rep,name=attachments" json:"attachments,omitempty"`
	Time                 *MailHeader_Time              `protobuf:"bytes,9,opt,name=time" json:"time,omitempty"`
	Status               *MailHeader_Status            `protobuf:"bytes,10,opt,name=status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *MailHeader) Reset()         { *m = MailHeader{} }
func (m *MailHeader) String() string { return proto.CompactTextString(m) }
func (*MailHeader) ProtoMessage()    {}
func (*MailHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{0}
}
func (m *MailHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MailHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MailHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MailHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MailHeader.Merge(dst, src)
}
func (m *MailHeader) XXX_Size() int {
	return m.Size()
}
func (m *MailHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_MailHeader.DiscardUnknown(m)
}

var xxx_messageInfo_MailHeader proto.InternalMessageInfo

func (m *MailHeader) GetFrom() []byte {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *MailHeader) GetFromNick() []byte {
	if m != nil {
		return m.FromNick
	}
	return nil
}

func (m *MailHeader) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *MailHeader) GetToNick() []byte {
	if m != nil {
		return m.ToNick
	}
	return nil
}

func (m *MailHeader) GetTitle() []byte {
	if m != nil {
		return m.Title
	}
	return nil
}

func (m *MailHeader) GetBrief() []byte {
	if m != nil {
		return m.Brief
	}
	return nil
}

func (m *MailHeader) GetBodyLen() uint32 {
	if m != nil {
		return m.BodyLen
	}
	return 0
}

func (m *MailHeader) GetAttachments() []*MailHeader_AttachmentBrief {
	if m != nil {
		return m.Attachments
	}
	return nil
}

func (m *MailHeader) GetTime() *MailHeader_Time {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *MailHeader) GetStatus() *MailHeader_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type MailHeader_AttachmentBrief struct {
	Index uint32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Brief []byte `protobuf:"bytes,2,opt,name=brief,proto3" json:"brief,omitempty"`
	// 多数游戏的附件为道具
	ItemId               uint64   `protobuf:"varint,5,opt,name=item_id,json=itemId,proto3" json:"item_id,omitempty"`
	Item                 []byte   `protobuf:"bytes,3,opt,name=item,proto3" json:"item,omitempty"`
	Count                uint32   `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MailHeader_AttachmentBrief) Reset()         { *m = MailHeader_AttachmentBrief{} }
func (m *MailHeader_AttachmentBrief) String() string { return proto.CompactTextString(m) }
func (*MailHeader_AttachmentBrief) ProtoMessage()    {}
func (*MailHeader_AttachmentBrief) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{0, 0}
}
func (m *MailHeader_AttachmentBrief) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MailHeader_AttachmentBrief) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MailHeader_AttachmentBrief.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MailHeader_AttachmentBrief) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MailHeader_AttachmentBrief.Merge(dst, src)
}
func (m *MailHeader_AttachmentBrief) XXX_Size() int {
	return m.Size()
}
func (m *MailHeader_AttachmentBrief) XXX_DiscardUnknown() {
	xxx_messageInfo_MailHeader_AttachmentBrief.DiscardUnknown(m)
}

var xxx_messageInfo_MailHeader_AttachmentBrief proto.InternalMessageInfo

func (m *MailHeader_AttachmentBrief) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *MailHeader_AttachmentBrief) GetBrief() []byte {
	if m != nil {
		return m.Brief
	}
	return nil
}

func (m *MailHeader_AttachmentBrief) GetItemId() uint64 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *MailHeader_AttachmentBrief) GetItem() []byte {
	if m != nil {
		return m.Item
	}
	return nil
}

func (m *MailHeader_AttachmentBrief) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type MailHeader_Time struct {
	Send                 int64    `protobuf:"varint,1,opt,name=send,proto3" json:"send,omitempty"`
	Expire               int64    `protobuf:"varint,2,opt,name=expire,proto3" json:"expire,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MailHeader_Time) Reset()         { *m = MailHeader_Time{} }
func (m *MailHeader_Time) String() string { return proto.CompactTextString(m) }
func (*MailHeader_Time) ProtoMessage()    {}
func (*MailHeader_Time) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{0, 1}
}
func (m *MailHeader_Time) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MailHeader_Time) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MailHeader_Time.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MailHeader_Time) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MailHeader_Time.Merge(dst, src)
}
func (m *MailHeader_Time) XXX_Size() int {
	return m.Size()
}
func (m *MailHeader_Time) XXX_DiscardUnknown() {
	xxx_messageInfo_MailHeader_Time.DiscardUnknown(m)
}

var xxx_messageInfo_MailHeader_Time proto.InternalMessageInfo

func (m *MailHeader_Time) GetSend() int64 {
	if m != nil {
		return m.Send
	}
	return 0
}

func (m *MailHeader_Time) GetExpire() int64 {
	if m != nil {
		return m.Expire
	}
	return 0
}

type MailHeader_Status struct {
	Read                 bool     `protobuf:"varint,1,opt,name=read,proto3" json:"read,omitempty"`
	AttachmentsReceived  bool     `protobuf:"varint,2,opt,name=attachments_received,json=attachmentsReceived,proto3" json:"attachments_received,omitempty"`
	CustomData           []byte   `protobuf:"bytes,3,opt,name=custom_data,json=customData,proto3" json:"custom_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MailHeader_Status) Reset()         { *m = MailHeader_Status{} }
func (m *MailHeader_Status) String() string { return proto.CompactTextString(m) }
func (*MailHeader_Status) ProtoMessage()    {}
func (*MailHeader_Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{0, 2}
}
func (m *MailHeader_Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MailHeader_Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MailHeader_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MailHeader_Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MailHeader_Status.Merge(dst, src)
}
func (m *MailHeader_Status) XXX_Size() int {
	return m.Size()
}
func (m *MailHeader_Status) XXX_DiscardUnknown() {
	xxx_messageInfo_MailHeader_Status.DiscardUnknown(m)
}

var xxx_messageInfo_MailHeader_Status proto.InternalMessageInfo

func (m *MailHeader_Status) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *MailHeader_Status) GetAttachmentsReceived() bool {
	if m != nil {
		return m.AttachmentsReceived
	}
	return false
}

func (m *MailHeader_Status) GetCustomData() []byte {
	if m != nil {
		return m.CustomData
	}
	return nil
}

// 邮件体是邮件正文和附件数据，比较大。邮件体须通过Get()方法单独获取。
type MailBody struct {
	Body                 []byte                     `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	Attachments          []*MailBody_AttachmentBody `protobuf:"bytes,2,rep,name=attachments" json:"attachments,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *MailBody) Reset()         { *m = MailBody{} }
func (m *MailBody) String() string { return proto.CompactTextString(m) }
func (*MailBody) ProtoMessage()    {}
func (*MailBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{1}
}
func (m *MailBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MailBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MailBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MailBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MailBody.Merge(dst, src)
}
func (m *MailBody) XXX_Size() int {
	return m.Size()
}
func (m *MailBody) XXX_DiscardUnknown() {
	xxx_messageInfo_MailBody.DiscardUnknown(m)
}

var xxx_messageInfo_MailBody proto.InternalMessageInfo

func (m *MailBody) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *MailBody) GetAttachments() []*MailBody_AttachmentBody {
	if m != nil {
		return m.Attachments
	}
	return nil
}

type MailBody_AttachmentBody struct {
	Index                uint32   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Body                 []byte   `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MailBody_AttachmentBody) Reset()         { *m = MailBody_AttachmentBody{} }
func (m *MailBody_AttachmentBody) String() string { return proto.CompactTextString(m) }
func (*MailBody_AttachmentBody) ProtoMessage()    {}
func (*MailBody_AttachmentBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{1, 0}
}
func (m *MailBody_AttachmentBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MailBody_AttachmentBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MailBody_AttachmentBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MailBody_AttachmentBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MailBody_AttachmentBody.Merge(dst, src)
}
func (m *MailBody_AttachmentBody) XXX_Size() int {
	return m.Size()
}
func (m *MailBody_AttachmentBody) XXX_DiscardUnknown() {
	xxx_messageInfo_MailBody_AttachmentBody.DiscardUnknown(m)
}

var xxx_messageInfo_MailBody_AttachmentBody proto.InternalMessageInfo

func (m *MailBody_AttachmentBody) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *MailBody_AttachmentBody) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

// 通用的结果消息
type Result struct {
	Ok                   bool     `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	Error                string   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{2}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(dst, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *Result) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type SendRequest struct {
	Header               *MailHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Body                 *MailBody   `protobuf:"bytes,2,opt,name=body" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SendRequest) Reset()         { *m = SendRequest{} }
func (m *SendRequest) String() string { return proto.CompactTextString(m) }
func (*SendRequest) ProtoMessage()    {}
func (*SendRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{3}
}
func (m *SendRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SendRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendRequest.Merge(dst, src)
}
func (m *SendRequest) XXX_Size() int {
	return m.Size()
}
func (m *SendRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendRequest proto.InternalMessageInfo

func (m *SendRequest) GetHeader() *MailHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *SendRequest) GetBody() *MailBody {
	if m != nil {
		return m.Body
	}
	return nil
}

type SendResponse struct {
	Result               *Result  `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	MailId               []byte   `protobuf:"bytes,3,opt,name=mail_id,json=mailId,proto3" json:"mail_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendResponse) Reset()         { *m = SendResponse{} }
func (m *SendResponse) String() string { return proto.CompactTextString(m) }
func (*SendResponse) ProtoMessage()    {}
func (*SendResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{4}
}
func (m *SendResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SendResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendResponse.Merge(dst, src)
}
func (m *SendResponse) XXX_Size() int {
	return m.Size()
}
func (m *SendResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SendResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SendResponse proto.InternalMessageInfo

func (m *SendResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *SendResponse) GetMailId() []byte {
	if m != nil {
		return m.MailId
	}
	return nil
}

type BroadcastRequest struct {
	Header               *MailHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Body                 *MailBody   `protobuf:"bytes,2,opt,name=body" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *BroadcastRequest) Reset()         { *m = BroadcastRequest{} }
func (m *BroadcastRequest) String() string { return proto.CompactTextString(m) }
func (*BroadcastRequest) ProtoMessage()    {}
func (*BroadcastRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{5}
}
func (m *BroadcastRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BroadcastRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BroadcastRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BroadcastRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BroadcastRequest.Merge(dst, src)
}
func (m *BroadcastRequest) XXX_Size() int {
	return m.Size()
}
func (m *BroadcastRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BroadcastRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BroadcastRequest proto.InternalMessageInfo

func (m *BroadcastRequest) GetHeader() *MailHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *BroadcastRequest) GetBody() *MailBody {
	if m != nil {
		return m.Body
	}
	return nil
}

type BroadcastResponse struct {
	Result               *Result  `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	MailId               []byte   `protobuf:"bytes,3,opt,name=mail_id,json=mailId,proto3" json:"mail_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BroadcastResponse) Reset()         { *m = BroadcastResponse{} }
func (m *BroadcastResponse) String() string { return proto.CompactTextString(m) }
func (*BroadcastResponse) ProtoMessage()    {}
func (*BroadcastResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{6}
}
func (m *BroadcastResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BroadcastResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BroadcastResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BroadcastResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BroadcastResponse.Merge(dst, src)
}
func (m *BroadcastResponse) XXX_Size() int {
	return m.Size()
}
func (m *BroadcastResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BroadcastResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BroadcastResponse proto.InternalMessageInfo

func (m *BroadcastResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *BroadcastResponse) GetMailId() []byte {
	if m != nil {
		return m.MailId
	}
	return nil
}

type GetMailCountRequest struct {
	To []byte `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	// 开始时间，unix time() 值。对于系统广播邮件，需要设置时间以去除建号以前的邮件。
	FromTime             int64    `protobuf:"varint,2,opt,name=from_time,json=fromTime,proto3" json:"from_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetMailCountRequest) Reset()         { *m = GetMailCountRequest{} }
func (m *GetMailCountRequest) String() string { return proto.CompactTextString(m) }
func (*GetMailCountRequest) ProtoMessage()    {}
func (*GetMailCountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{7}
}
func (m *GetMailCountRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMailCountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMailCountRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetMailCountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMailCountRequest.Merge(dst, src)
}
func (m *GetMailCountRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMailCountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMailCountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMailCountRequest proto.InternalMessageInfo

func (m *GetMailCountRequest) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *GetMailCountRequest) GetFromTime() int64 {
	if m != nil {
		return m.FromTime
	}
	return 0
}

type GetMailCountResponse struct {
	Result *Result `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	// 因为 total 和 read 是分别查询的，所以不一定 total >= read。
	Total                uint32   `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	Read                 uint32   `protobuf:"varint,3,opt,name=read,proto3" json:"read,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetMailCountResponse) Reset()         { *m = GetMailCountResponse{} }
func (m *GetMailCountResponse) String() string { return proto.CompactTextString(m) }
func (*GetMailCountResponse) ProtoMessage()    {}
func (*GetMailCountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{8}
}
func (m *GetMailCountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMailCountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMailCountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetMailCountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMailCountResponse.Merge(dst, src)
}
func (m *GetMailCountResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetMailCountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMailCountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMailCountResponse proto.InternalMessageInfo

func (m *GetMailCountResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *GetMailCountResponse) GetTotal() uint32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *GetMailCountResponse) GetRead() uint32 {
	if m != nil {
		return m.Read
	}
	return 0
}

type ListRequest struct {
	// 全服邮件和用户邮件是2个不同的列表。
	IsBroadcast bool   `protobuf:"varint,6,opt,name=is_broadcast,json=isBroadcast,proto3" json:"is_broadcast,omitempty"`
	To          []byte `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	// 邮件按发送时间排序. 时间相同则按邮件ID排序.
	// 默认查询最新邮件，列出 [start, end) 区间内的邮件，start 一般为空。
	// 如果 ascend = true, 即从最早的邮件开始查询，则列出 (start, end] 区间内的邮件, end 一般为空。
	// 分页列举时，首次查询可以让 start,end 都为空，
	//    如果返回个数等于 limit, 说明需要下一页查询。
	//    如果 ascend = false, 则将 end 设为上一页的最早一封邮件的时间和ID, start为空, 再次查询;
	//    如果 ascend = true，则将 start 设为上一页的最晚一封邮件的时间和ID, end为空，再次查询。
	//    如果返回个数小于 limit, 说明已查询完成所有分页。
	Start *ListRequest_TimeAndID `protobuf:"bytes,2,opt,name=start" json:"start,omitempty"`
	End   *ListRequest_TimeAndID `protobuf:"bytes,3,opt,name=end" json:"end,omitempty"`
	Limit uint32                 `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	// 缺省接降序排列，即先列出最新的邮件。
	// 如果需要从最早的邮件开始列，则需要升序排列。
	Ascend               bool     `protobuf:"varint,5,opt,name=ascend,proto3" json:"ascend,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListRequest) Reset()         { *m = ListRequest{} }
func (m *ListRequest) String() string { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()    {}
func (*ListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{9}
}
func (m *ListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRequest.Merge(dst, src)
}
func (m *ListRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRequest proto.InternalMessageInfo

func (m *ListRequest) GetIsBroadcast() bool {
	if m != nil {
		return m.IsBroadcast
	}
	return false
}

func (m *ListRequest) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *ListRequest) GetStart() *ListRequest_TimeAndID {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *ListRequest) GetEnd() *ListRequest_TimeAndID {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *ListRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListRequest) GetAscend() bool {
	if m != nil {
		return m.Ascend
	}
	return false
}

// 邮件按 (发送时间, 邮件ID) 排序
type ListRequest_TimeAndID struct {
	Time                 int64    `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	MailId               []byte   `protobuf:"bytes,2,opt,name=mail_id,json=mailId,proto3" json:"mail_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListRequest_TimeAndID) Reset()         { *m = ListRequest_TimeAndID{} }
func (m *ListRequest_TimeAndID) String() string { return proto.CompactTextString(m) }
func (*ListRequest_TimeAndID) ProtoMessage()    {}
func (*ListRequest_TimeAndID) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{9, 0}
}
func (m *ListRequest_TimeAndID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRequest_TimeAndID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRequest_TimeAndID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListRequest_TimeAndID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRequest_TimeAndID.Merge(dst, src)
}
func (m *ListRequest_TimeAndID) XXX_Size() int {
	return m.Size()
}
func (m *ListRequest_TimeAndID) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRequest_TimeAndID.DiscardUnknown(m)
}

var xxx_messageInfo_ListRequest_TimeAndID proto.InternalMessageInfo

func (m *ListRequest_TimeAndID) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *ListRequest_TimeAndID) GetMailId() []byte {
	if m != nil {
		return m.MailId
	}
	return nil
}

type MailHeaderWithID struct {
	MailId               []byte      `protobuf:"bytes,1,opt,name=mail_id,json=mailId,proto3" json:"mail_id,omitempty"`
	Header               *MailHeader `protobuf:"bytes,2,opt,name=header" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *MailHeaderWithID) Reset()         { *m = MailHeaderWithID{} }
func (m *MailHeaderWithID) String() string { return proto.CompactTextString(m) }
func (*MailHeaderWithID) ProtoMessage()    {}
func (*MailHeaderWithID) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{10}
}
func (m *MailHeaderWithID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MailHeaderWithID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MailHeaderWithID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MailHeaderWithID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MailHeaderWithID.Merge(dst, src)
}
func (m *MailHeaderWithID) XXX_Size() int {
	return m.Size()
}
func (m *MailHeaderWithID) XXX_DiscardUnknown() {
	xxx_messageInfo_MailHeaderWithID.DiscardUnknown(m)
}

var xxx_messageInfo_MailHeaderWithID proto.InternalMessageInfo

func (m *MailHeaderWithID) GetMailId() []byte {
	if m != nil {
		return m.MailId
	}
	return nil
}

func (m *MailHeaderWithID) GetHeader() *MailHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type ListResponse struct {
	Result               *Result             `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	Mails                []*MailHeaderWithID `protobuf:"bytes,2,rep,name=mails" json:"mails,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ListResponse) Reset()         { *m = ListResponse{} }
func (m *ListResponse) String() string { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()    {}
func (*ListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{11}
}
func (m *ListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListResponse.Merge(dst, src)
}
func (m *ListResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListResponse proto.InternalMessageInfo

func (m *ListResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ListResponse) GetMails() []*MailHeaderWithID {
	if m != nil {
		return m.Mails
	}
	return nil
}

// 邮件索引
type MailIndex struct {
	To                   []byte   `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
	IsBroadcast          bool     `protobuf:"varint,2,opt,name=is_broadcast,json=isBroadcast,proto3" json:"is_broadcast,omitempty"`
	MailId               []byte   `protobuf:"bytes,3,opt,name=mail_id,json=mailId,proto3" json:"mail_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MailIndex) Reset()         { *m = MailIndex{} }
func (m *MailIndex) String() string { return proto.CompactTextString(m) }
func (*MailIndex) ProtoMessage()    {}
func (*MailIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{12}
}
func (m *MailIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MailIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MailIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MailIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MailIndex.Merge(dst, src)
}
func (m *MailIndex) XXX_Size() int {
	return m.Size()
}
func (m *MailIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_MailIndex.DiscardUnknown(m)
}

var xxx_messageInfo_MailIndex proto.InternalMessageInfo

func (m *MailIndex) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *MailIndex) GetIsBroadcast() bool {
	if m != nil {
		return m.IsBroadcast
	}
	return false
}

func (m *MailIndex) GetMailId() []byte {
	if m != nil {
		return m.MailId
	}
	return nil
}

type GetRequest struct {
	MailIndex            *MailIndex `protobuf:"bytes,1,opt,name=mail_index,json=mailIndex" json:"mail_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}
func (*GetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{13}
}
func (m *GetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest.Merge(dst, src)
}
func (m *GetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest proto.InternalMessageInfo

func (m *GetRequest) GetMailIndex() *MailIndex {
	if m != nil {
		return m.MailIndex
	}
	return nil
}

type GetResponse struct {
	Result               *Result   `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	Body                 *MailBody `protobuf:"bytes,2,opt,name=body" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetResponse) Reset()         { *m = GetResponse{} }
func (m *GetResponse) String() string { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()    {}
func (*GetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{14}
}
func (m *GetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetResponse.Merge(dst, src)
}
func (m *GetResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetResponse proto.InternalMessageInfo

func (m *GetResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *GetResponse) GetBody() *MailBody {
	if m != nil {
		return m.Body
	}
	return nil
}

type DeleteRequest struct {
	MailIndex            *MailIndex `protobuf:"bytes,1,opt,name=mail_index,json=mailIndex" json:"mail_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DeleteRequest) Reset()         { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()    {}
func (*DeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{15}
}
func (m *DeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRequest.Merge(dst, src)
}
func (m *DeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRequest proto.InternalMessageInfo

func (m *DeleteRequest) GetMailIndex() *MailIndex {
	if m != nil {
		return m.MailIndex
	}
	return nil
}

type DeleteResponse struct {
	Result               *Result  `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteResponse) Reset()         { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()    {}
func (*DeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{16}
}
func (m *DeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteResponse.Merge(dst, src)
}
func (m *DeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteResponse proto.InternalMessageInfo

func (m *DeleteResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

type MarkAsReadRequest struct {
	MailIndex            *MailIndex `protobuf:"bytes,1,opt,name=mail_index,json=mailIndex" json:"mail_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MarkAsReadRequest) Reset()         { *m = MarkAsReadRequest{} }
func (m *MarkAsReadRequest) String() string { return proto.CompactTextString(m) }
func (*MarkAsReadRequest) ProtoMessage()    {}
func (*MarkAsReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{17}
}
func (m *MarkAsReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkAsReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkAsReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MarkAsReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkAsReadRequest.Merge(dst, src)
}
func (m *MarkAsReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *MarkAsReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkAsReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MarkAsReadRequest proto.InternalMessageInfo

func (m *MarkAsReadRequest) GetMailIndex() *MailIndex {
	if m != nil {
		return m.MailIndex
	}
	return nil
}

type MarkAsReadResponse struct {
	Result               *Result  `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkAsReadResponse) Reset()         { *m = MarkAsReadResponse{} }
func (m *MarkAsReadResponse) String() string { return proto.CompactTextString(m) }
func (*MarkAsReadResponse) ProtoMessage()    {}
func (*MarkAsReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{18}
}
func (m *MarkAsReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkAsReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkAsReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MarkAsReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkAsReadResponse.Merge(dst, src)
}
func (m *MarkAsReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *MarkAsReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkAsReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MarkAsReadResponse proto.InternalMessageInfo

func (m *MarkAsReadResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

type MarkAsUnreadRequest struct {
	MailIndex            *MailIndex `protobuf:"bytes,1,opt,name=mail_index,json=mailIndex" json:"mail_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MarkAsUnreadRequest) Reset()         { *m = MarkAsUnreadRequest{} }
func (m *MarkAsUnreadRequest) String() string { return proto.CompactTextString(m) }
func (*MarkAsUnreadRequest) ProtoMessage()    {}
func (*MarkAsUnreadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{19}
}
func (m *MarkAsUnreadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkAsUnreadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkAsUnreadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MarkAsUnreadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkAsUnreadRequest.Merge(dst, src)
}
func (m *MarkAsUnreadRequest) XXX_Size() int {
	return m.Size()
}
func (m *MarkAsUnreadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkAsUnreadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MarkAsUnreadRequest proto.InternalMessageInfo

func (m *MarkAsUnreadRequest) GetMailIndex() *MailIndex {
	if m != nil {
		return m.MailIndex
	}
	return nil
}

type MarkAsUnreadResponse struct {
	Result               *Result  `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkAsUnreadResponse) Reset()         { *m = MarkAsUnreadResponse{} }
func (m *MarkAsUnreadResponse) String() string { return proto.CompactTextString(m) }
func (*MarkAsUnreadResponse) ProtoMessage()    {}
func (*MarkAsUnreadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{20}
}
func (m *MarkAsUnreadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkAsUnreadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkAsUnreadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MarkAsUnreadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkAsUnreadResponse.Merge(dst, src)
}
func (m *MarkAsUnreadResponse) XXX_Size() int {
	return m.Size()
}
func (m *MarkAsUnreadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkAsUnreadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MarkAsUnreadResponse proto.InternalMessageInfo

func (m *MarkAsUnreadResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

type MarkAttachmentsAsReceivedRequest struct {
	MailIndex            *MailIndex `protobuf:"bytes,1,opt,name=mail_index,json=mailIndex" json:"mail_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MarkAttachmentsAsReceivedRequest) Reset()         { *m = MarkAttachmentsAsReceivedRequest{} }
func (m *MarkAttachmentsAsReceivedRequest) String() string { return proto.CompactTextString(m) }
func (*MarkAttachmentsAsReceivedRequest) ProtoMessage()    {}
func (*MarkAttachmentsAsReceivedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{21}
}
func (m *MarkAttachmentsAsReceivedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkAttachmentsAsReceivedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkAttachmentsAsReceivedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MarkAttachmentsAsReceivedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkAttachmentsAsReceivedRequest.Merge(dst, src)
}
func (m *MarkAttachmentsAsReceivedRequest) XXX_Size() int {
	return m.Size()
}
func (m *MarkAttachmentsAsReceivedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkAttachmentsAsReceivedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MarkAttachmentsAsReceivedRequest proto.InternalMessageInfo

func (m *MarkAttachmentsAsReceivedRequest) GetMailIndex() *MailIndex {
	if m != nil {
		return m.MailIndex
	}
	return nil
}

type MarkAttachmentsAsReceivedResponse struct {
	Result               *Result  `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	CheckFailed          bool     `protobuf:"varint,2,opt,name=check_failed,json=checkFailed,proto3" json:"check_failed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkAttachmentsAsReceivedResponse) Reset()         { *m = MarkAttachmentsAsReceivedResponse{} }
func (m *MarkAttachmentsAsReceivedResponse) String() string { return proto.CompactTextString(m) }
func (*MarkAttachmentsAsReceivedResponse) ProtoMessage()    {}
func (*MarkAttachmentsAsReceivedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{22}
}
func (m *MarkAttachmentsAsReceivedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkAttachmentsAsReceivedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkAttachmentsAsReceivedResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MarkAttachmentsAsReceivedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkAttachmentsAsReceivedResponse.Merge(dst, src)
}
func (m *MarkAttachmentsAsReceivedResponse) XXX_Size() int {
	return m.Size()
}
func (m *MarkAttachmentsAsReceivedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkAttachmentsAsReceivedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MarkAttachmentsAsReceivedResponse proto.InternalMessageInfo

func (m *MarkAttachmentsAsReceivedResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *MarkAttachmentsAsReceivedResponse) GetCheckFailed() bool {
	if m != nil {
		return m.CheckFailed
	}
	return false
}

type SetCustomDataRequest struct {
	MailIndex            *MailIndex `protobuf:"bytes,1,opt,name=mail_index,json=mailIndex" json:"mail_index,omitempty"`
	CustomData           []byte     `protobuf:"bytes,2,opt,name=custom_data,json=customData,proto3" json:"custom_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SetCustomDataRequest) Reset()         { *m = SetCustomDataRequest{} }
func (m *SetCustomDataRequest) String() string { return proto.CompactTextString(m) }
func (*SetCustomDataRequest) ProtoMessage()    {}
func (*SetCustomDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{23}
}
func (m *SetCustomDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCustomDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCustomDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SetCustomDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCustomDataRequest.Merge(dst, src)
}
func (m *SetCustomDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetCustomDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCustomDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetCustomDataRequest proto.InternalMessageInfo

func (m *SetCustomDataRequest) GetMailIndex() *MailIndex {
	if m != nil {
		return m.MailIndex
	}
	return nil
}

func (m *SetCustomDataRequest) GetCustomData() []byte {
	if m != nil {
		return m.CustomData
	}
	return nil
}

type SetCustomDataResponse struct {
	Result               *Result  `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetCustomDataResponse) Reset()         { *m = SetCustomDataResponse{} }
func (m *SetCustomDataResponse) String() string { return proto.CompactTextString(m) }
func (*SetCustomDataResponse) ProtoMessage()    {}
func (*SetCustomDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{24}
}
func (m *SetCustomDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCustomDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCustomDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SetCustomDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCustomDataResponse.Merge(dst, src)
}
func (m *SetCustomDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetCustomDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCustomDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetCustomDataResponse proto.InternalMessageInfo

func (m *SetCustomDataResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

type SubscribeRequest struct {
	IsSubscribe          bool     `protobuf:"varint,1,opt,name=is_subscribe,json=isSubscribe,proto3" json:"is_subscribe,omitempty"`
	To                   []byte   `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeRequest) Reset()         { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()    {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{25}
}
func (m *SubscribeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeRequest.Merge(dst, src)
}
func (m *SubscribeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeRequest proto.InternalMessageInfo

func (m *SubscribeRequest) GetIsSubscribe() bool {
	if m != nil {
		return m.IsSubscribe
	}
	return false
}

func (m *SubscribeRequest) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

type NewMailNotification struct {
	OBSOLETEIsBroadcast bool                `protobuf:"varint,1,opt,name=OBSOLETE_is_broadcast,json=OBSOLETEIsBroadcast,proto3" json:"OBSOLETE_is_broadcast,omitempty"`
	OBSOLETEToList      [][]byte            `protobuf:"bytes,2,rep,name=OBSOLETE_to_list,json=OBSOLETEToList" json:"OBSOLETE_to_list,omitempty"`
	BroadcastMails      []*MailHeaderWithID `protobuf:"bytes,3,rep,name=broadcast_mails,json=broadcastMails" json:"broadcast_mails,omitempty"`
	// 非广播邮件，即用户邮件。仅订阅的收信人。
	UserMails            []*MailHeaderWithID `protobuf:"bytes,4,rep,name=user_mails,json=userMails" json:"user_mails,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *NewMailNotification) Reset()         { *m = NewMailNotification{} }
func (m *NewMailNotification) String() string { return proto.CompactTextString(m) }
func (*NewMailNotification) ProtoMessage()    {}
func (*NewMailNotification) Descriptor() ([]byte, []int) {
	return fileDescriptor_mail_651a9a4d896d6f04, []int{26}
}
func (m *NewMailNotification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewMailNotification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewMailNotification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NewMailNotification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewMailNotification.Merge(dst, src)
}
func (m *NewMailNotification) XXX_Size() int {
	return m.Size()
}
func (m *NewMailNotification) XXX_DiscardUnknown() {
	xxx_messageInfo_NewMailNotification.DiscardUnknown(m)
}

var xxx_messageInfo_NewMailNotification proto.InternalMessageInfo

func (m *NewMailNotification) GetOBSOLETEIsBroadcast() bool {
	if m != nil {
		return m.OBSOLETEIsBroadcast
	}
	return false
}

func (m *NewMailNotification) GetOBSOLETEToList() [][]byte {
	if m != nil {
		return m.OBSOLETEToList
	}
	return nil
}

func (m *NewMailNotification) GetBroadcastMails() []*MailHeaderWithID {
	if m != nil {
		return m.BroadcastMails
	}
	return nil
}

func (m *NewMailNotification) GetUserMails() []*MailHeaderWithID {
	if m != nil {
		return m.UserMails
	}
	return nil
}

func init() {
	proto.RegisterType((*MailHeader)(nil), "pb.MailHeader")
	proto.RegisterType((*MailHeader_AttachmentBrief)(nil), "pb.MailHeader.AttachmentBrief")
	proto.RegisterType((*MailHeader_Time)(nil), "pb.MailHeader.Time")
	proto.RegisterType((*MailHeader_Status)(nil), "pb.MailHeader.Status")
	proto.RegisterType((*MailBody)(nil), "pb.MailBody")
	proto.RegisterType((*MailBody_AttachmentBody)(nil), "pb.MailBody.AttachmentBody")
	proto.RegisterType((*Result)(nil), "pb.Result")
	proto.RegisterType((*SendRequest)(nil), "pb.SendRequest")
	proto.RegisterType((*SendResponse)(nil), "pb.SendResponse")
	proto.RegisterType((*BroadcastRequest)(nil), "pb.BroadcastRequest")
	proto.RegisterType((*BroadcastResponse)(nil), "pb.BroadcastResponse")
	proto.RegisterType((*GetMailCountRequest)(nil), "pb.GetMailCountRequest")
	proto.RegisterType((*GetMailCountResponse)(nil), "pb.GetMailCountResponse")
	proto.RegisterType((*ListRequest)(nil), "pb.ListRequest")
	proto.RegisterType((*ListRequest_TimeAndID)(nil), "pb.ListRequest.TimeAndID")
	proto.RegisterType((*MailHeaderWithID)(nil), "pb.MailHeaderWithID")
	proto.RegisterType((*ListResponse)(nil), "pb.ListResponse")
	proto.RegisterType((*MailIndex)(nil), "pb.MailIndex")
	proto.RegisterType((*GetRequest)(nil), "pb.GetRequest")
	proto.RegisterType((*GetResponse)(nil), "pb.GetResponse")
	proto.RegisterType((*DeleteRequest)(nil), "pb.DeleteRequest")
	proto.RegisterType((*DeleteResponse)(nil), "pb.DeleteResponse")
	proto.RegisterType((*MarkAsReadRequest)(nil), "pb.MarkAsReadRequest")
	proto.RegisterType((*MarkAsReadResponse)(nil), "pb.MarkAsReadResponse")
	proto.RegisterType((*MarkAsUnreadRequest)(nil), "pb.MarkAsUnreadRequest")
	proto.RegisterType((*MarkAsUnreadResponse)(nil), "pb.MarkAsUnreadResponse")
	proto.RegisterType((*MarkAttachmentsAsReceivedRequest)(nil), "pb.MarkAttachmentsAsReceivedRequest")
	proto.RegisterType((*MarkAttachmentsAsReceivedResponse)(nil), "pb.MarkAttachmentsAsReceivedResponse")
	proto.RegisterType((*SetCustomDataRequest)(nil), "pb.SetCustomDataRequest")
	proto.RegisterType((*SetCustomDataResponse)(nil), "pb.SetCustomDataResponse")
	proto.RegisterType((*SubscribeRequest)(nil), "pb.SubscribeRequest")
	proto.RegisterType((*NewMailNotification)(nil), "pb.NewMailNotification")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MailClient is the client API for Mail service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MailClient interface {
	// 发邮件
	Send(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error)
	// 发全服邮件.
	Broadcast(ctx context.Context, in *BroadcastRequest, opts ...grpc.CallOption) (*BroadcastResponse, error)
	// 查询邮件数和已读邮件数
	GetMailCount(ctx context.Context, in *GetMailCountRequest, opts ...grpc.CallOption) (*GetMailCountResponse, error)
	// 查询邮件列表
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	// 查询一封邮件的内容
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// 删除一封邮件
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	// 标记邮件已读/未读
	MarkAsRead(ctx context.Context, in *MarkAsReadRequest, opts ...grpc.CallOption) (*MarkAsReadResponse, error)
	MarkAsUnread(ctx context.Context, in *MarkAsUnreadRequest, opts ...grpc.CallOption) (*MarkAsUnreadResponse, error)
	// 标记附件已领取，只有在未领取状态下才会成功
	MarkAttachmentsAsReceived(ctx context.Context, in *MarkAttachmentsAsReceivedRequest, opts ...grpc.CallOption) (*MarkAttachmentsAsReceivedResponse, error)
	// 设置邮件自定义数据. 可保存任意数据, 例如阅读进度，标签.
	SetCustomData(ctx context.Context, in *SetCustomDataRequest, opts ...grpc.CallOption) (*SetCustomDataResponse, error)
	// 获取新邮件通知
	GetNewMailNotifications(ctx context.Context, opts ...grpc.CallOption) (Mail_GetNewMailNotificationsClient, error)
}

type mailClient struct {
	cc *grpc.ClientConn
}

func NewMailClient(cc *grpc.ClientConn) MailClient {
	return &mailClient{cc}
}

func (c *mailClient) Send(ctx context.Context, in *SendRequest, opts ...grpc.CallOption) (*SendResponse, error) {
	out := new(SendResponse)
	err := c.cc.Invoke(ctx, "/pb.Mail/Send", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) Broadcast(ctx context.Context, in *BroadcastRequest, opts ...grpc.CallOption) (*BroadcastResponse, error) {
	out := new(BroadcastResponse)
	err := c.cc.Invoke(ctx, "/pb.Mail/Broadcast", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) GetMailCount(ctx context.Context, in *GetMailCountRequest, opts ...grpc.CallOption) (*GetMailCountResponse, error) {
	out := new(GetMailCountResponse)
	err := c.cc.Invoke(ctx, "/pb.Mail/GetMailCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := c.cc.Invoke(ctx, "/pb.Mail/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, "/pb.Mail/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, "/pb.Mail/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) MarkAsRead(ctx context.Context, in *MarkAsReadRequest, opts ...grpc.CallOption) (*MarkAsReadResponse, error) {
	out := new(MarkAsReadResponse)
	err := c.cc.Invoke(ctx, "/pb.Mail/MarkAsRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) MarkAsUnread(ctx context.Context, in *MarkAsUnreadRequest, opts ...grpc.CallOption) (*MarkAsUnreadResponse, error) {
	out := new(MarkAsUnreadResponse)
	err := c.cc.Invoke(ctx, "/pb.Mail/MarkAsUnread", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) MarkAttachmentsAsReceived(ctx context.Context, in *MarkAttachmentsAsReceivedRequest, opts ...grpc.CallOption) (*MarkAttachmentsAsReceivedResponse, error) {
	out := new(MarkAttachmentsAsReceivedResponse)
	err := c.cc.Invoke(ctx, "/pb.Mail/MarkAttachmentsAsReceived", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) SetCustomData(ctx context.Context, in *SetCustomDataRequest, opts ...grpc.CallOption) (*SetCustomDataResponse, error) {
	out := new(SetCustomDataResponse)
	err := c.cc.Invoke(ctx, "/pb.Mail/SetCustomData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) GetNewMailNotifications(ctx context.Context, opts ...grpc.CallOption) (Mail_GetNewMailNotificationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Mail_serviceDesc.Streams[0], "/pb.Mail/GetNewMailNotifications", opts...)
	if err != nil {
		return nil, err
	}
	x := &mailGetNewMailNotificationsClient{stream}
	return x, nil
}

type Mail_GetNewMailNotificationsClient interface {
	Send(*SubscribeRequest) error
	Recv() (*NewMailNotification, error)
	grpc.ClientStream
}

type mailGetNewMailNotificationsClient struct {
	grpc.ClientStream
}

func (x *mailGetNewMailNotificationsClient) Send(m *SubscribeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mailGetNewMailNotificationsClient) Recv() (*NewMailNotification, error) {
	m := new(NewMailNotification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Mail service

type MailServer interface {
	// 发邮件
	Send(context.Context, *SendRequest) (*SendResponse, error)
	// 发全服邮件.
	Broadcast(context.Context, *BroadcastRequest) (*BroadcastResponse, error)
	// 查询邮件数和已读邮件数
	GetMailCount(context.Context, *GetMailCountRequest) (*GetMailCountResponse, error)
	// 查询邮件列表
	List(context.Context, *ListRequest) (*ListResponse, error)
	// 查询一封邮件的内容
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// 删除一封邮件
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	// 标记邮件已读/未读
	MarkAsRead(context.Context, *MarkAsReadRequest) (*MarkAsReadResponse, error)
	MarkAsUnread(context.Context, *MarkAsUnreadRequest) (*MarkAsUnreadResponse, error)
	// 标记附件已领取，只有在未领取状态下才会成功
	MarkAttachmentsAsReceived(context.Context, *MarkAttachmentsAsReceivedRequest) (*MarkAttachmentsAsReceivedResponse, error)
	// 设置邮件自定义数据. 可保存任意数据, 例如阅读进度，标签.
	SetCustomData(context.Context, *SetCustomDataRequest) (*SetCustomDataResponse, error)
	// 获取新邮件通知
	GetNewMailNotifications(Mail_GetNewMailNotificationsServer) error
}

func RegisterMailServer(s *grpc.Server, srv MailServer) {
	s.RegisterService(&_Mail_serviceDesc, srv)
}

func _Mail_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/Send",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Send(ctx, req.(*SendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_Broadcast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Broadcast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/Broadcast",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Broadcast(ctx, req.(*BroadcastRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_GetMailCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMailCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).GetMailCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/GetMailCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).GetMailCount(ctx, req.(*GetMailCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_MarkAsRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAsReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).MarkAsRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/MarkAsRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).MarkAsRead(ctx, req.(*MarkAsReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_MarkAsUnread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAsUnreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).MarkAsUnread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/MarkAsUnread",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).MarkAsUnread(ctx, req.(*MarkAsUnreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_MarkAttachmentsAsReceived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAttachmentsAsReceivedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).MarkAttachmentsAsReceived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/MarkAttachmentsAsReceived",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).MarkAttachmentsAsReceived(ctx, req.(*MarkAttachmentsAsReceivedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_SetCustomData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCustomDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).SetCustomData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Mail/SetCustomData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).SetCustomData(ctx, req.(*SetCustomDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_GetNewMailNotifications_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MailServer).GetNewMailNotifications(&mailGetNewMailNotificationsServer{stream})
}

type Mail_GetNewMailNotificationsServer interface {
	Send(*NewMailNotification) error
	Recv() (*SubscribeRequest, error)
	grpc.ServerStream
}

type mailGetNewMailNotificationsServer struct {
	grpc.ServerStream
}

func (x *mailGetNewMailNotificationsServer) Send(m *NewMailNotification) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mailGetNewMailNotificationsServer) Recv() (*SubscribeRequest, error) {
	m := new(SubscribeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Mail_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Mail",
	HandlerType: (*MailServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Mail_Send_Handler,
		},
		{
			MethodName: "Broadcast",
			Handler:    _Mail_Broadcast_Handler,
		},
		{
			MethodName: "GetMailCount",
			Handler:    _Mail_GetMailCount_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Mail_List_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Mail_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Mail_Delete_Handler,
		},
		{
			MethodName: "MarkAsRead",
			Handler:    _Mail_MarkAsRead_Handler,
		},
		{
			MethodName: "MarkAsUnread",
			Handler:    _Mail_MarkAsUnread_Handler,
		},
		{
			MethodName: "MarkAttachmentsAsReceived",
			Handler:    _Mail_MarkAttachmentsAsReceived_Handler,
		},
		{
			MethodName: "SetCustomData",
			Handler:    _Mail_SetCustomData_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetNewMailNotifications",
			Handler:       _Mail_GetNewMailNotifications_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pb/mail.proto",
}

func (m *MailHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.From) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if len(m.FromNick) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.FromNick)))
		i += copy(dAtA[i:], m.FromNick)
	}
	if len(m.To) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if len(m.ToNick) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.ToNick)))
		i += copy(dAtA[i:], m.ToNick)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Brief) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Brief)))
		i += copy(dAtA[i:], m.Brief)
	}
	if m.BodyLen != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.BodyLen))
	}
	if len(m.Attachments) > 0 {
		for _, msg := range m.Attachments {
			dAtA[i] = 0x42
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Time != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Time.Size()))
		n1, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Status != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Status.Size()))
		n2, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *MailHeader_AttachmentBrief) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailHeader_AttachmentBrief) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Index))
	}
	if len(m.Brief) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Brief)))
		i += copy(dAtA[i:], m.Brief)
	}
	if len(m.Item) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Item)))
		i += copy(dAtA[i:], m.Item)
	}
	if m.Count != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Count))
	}
	if m.ItemId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.ItemId))
	}
	return i, nil
}

func (m *MailHeader_Time) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailHeader_Time) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Send != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Send))
	}
	if m.Expire != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Expire))
	}
	return i, nil
}

func (m *MailHeader_Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailHeader_Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Read {
		dAtA[i] = 0x8
		i++
		if m.Read {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AttachmentsReceived {
		dAtA[i] = 0x10
		i++
		if m.AttachmentsReceived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CustomData) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.CustomData)))
		i += copy(dAtA[i:], m.CustomData)
	}
	return i, nil
}

func (m *MailBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailBody) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if len(m.Attachments) > 0 {
		for _, msg := range m.Attachments {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MailBody_AttachmentBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailBody_AttachmentBody) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Index))
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	return i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ok {
		dAtA[i] = 0x8
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *SendRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Header.Size()))
		n3, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Body != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Body.Size()))
		n4, err := m.Body.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *SendResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n5, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.MailId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.MailId)))
		i += copy(dAtA[i:], m.MailId)
	}
	return i, nil
}

func (m *BroadcastRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Header.Size()))
		n6, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Body != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Body.Size()))
		n7, err := m.Body.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *BroadcastResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n8, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.MailId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.MailId)))
		i += copy(dAtA[i:], m.MailId)
	}
	return i, nil
}

func (m *GetMailCountRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMailCountRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.To) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if m.FromTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.FromTime))
	}
	return i, nil
}

func (m *GetMailCountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMailCountResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n9, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Total != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Total))
	}
	if m.Read != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Read))
	}
	return i, nil
}

func (m *ListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.To) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if m.Start != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Start.Size()))
		n10, err := m.Start.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.End != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.End.Size()))
		n11, err := m.End.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Limit))
	}
	if m.Ascend {
		dAtA[i] = 0x28
		i++
		if m.Ascend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsBroadcast {
		dAtA[i] = 0x30
		i++
		if m.IsBroadcast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ListRequest_TimeAndID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRequest_TimeAndID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Time))
	}
	if len(m.MailId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.MailId)))
		i += copy(dAtA[i:], m.MailId)
	}
	return i, nil
}

func (m *MailHeaderWithID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailHeaderWithID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MailId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.MailId)))
		i += copy(dAtA[i:], m.MailId)
	}
	if m.Header != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Header.Size()))
		n12, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *ListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n13, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Mails) > 0 {
		for _, msg := range m.Mails {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MailIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.To) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if m.IsBroadcast {
		dAtA[i] = 0x10
		i++
		if m.IsBroadcast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.MailId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.MailId)))
		i += copy(dAtA[i:], m.MailId)
	}
	return i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MailIndex != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailIndex.Size()))
		n14, err := m.MailIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *GetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n15, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Body != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Body.Size()))
		n16, err := m.Body.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *DeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MailIndex != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailIndex.Size()))
		n17, err := m.MailIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *DeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n18, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *MarkAsReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkAsReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MailIndex != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailIndex.Size()))
		n19, err := m.MailIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *MarkAsReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkAsReadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n20, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *MarkAsUnreadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkAsUnreadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MailIndex != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailIndex.Size()))
		n21, err := m.MailIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *MarkAsUnreadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkAsUnreadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n22, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *MarkAttachmentsAsReceivedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkAttachmentsAsReceivedRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MailIndex != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailIndex.Size()))
		n23, err := m.MailIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *MarkAttachmentsAsReceivedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkAttachmentsAsReceivedResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n24, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.CheckFailed {
		dAtA[i] = 0x10
		i++
		if m.CheckFailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SetCustomDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCustomDataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MailIndex != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailIndex.Size()))
		n25, err := m.MailIndex.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if len(m.CustomData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.CustomData)))
		i += copy(dAtA[i:], m.CustomData)
	}
	return i, nil
}

func (m *SetCustomDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCustomDataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Result.Size()))
		n26, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *SubscribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsSubscribe {
		dAtA[i] = 0x8
		i++
		if m.IsSubscribe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.To) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	return i, nil
}

func (m *NewMailNotification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewMailNotification) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OBSOLETEIsBroadcast {
		dAtA[i] = 0x8
		i++
		if m.OBSOLETEIsBroadcast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.OBSOLETEToList) > 0 {
		for _, b := range m.OBSOLETEToList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMail(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.BroadcastMails) > 0 {
		for _, msg := range m.BroadcastMails {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UserMails) > 0 {
		for _, msg := range m.UserMails {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintMail(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MailHeader) Size() (n int) {
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.FromNick)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.ToNick)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.Brief)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.BodyLen != 0 {
		n += 1 + sovMail(uint64(m.BodyLen))
	}
	if len(m.Attachments) > 0 {
		for _, e := range m.Attachments {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MailHeader_AttachmentBrief) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovMail(uint64(m.Index))
	}
	l = len(m.Brief)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.Item)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovMail(uint64(m.Count))
	}
	if m.ItemId != 0 {
		n += 1 + sovMail(uint64(m.ItemId))
	}
	return n
}

func (m *MailHeader_Time) Size() (n int) {
	var l int
	_ = l
	if m.Send != 0 {
		n += 1 + sovMail(uint64(m.Send))
	}
	if m.Expire != 0 {
		n += 1 + sovMail(uint64(m.Expire))
	}
	return n
}

func (m *MailHeader_Status) Size() (n int) {
	var l int
	_ = l
	if m.Read {
		n += 2
	}
	if m.AttachmentsReceived {
		n += 2
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MailBody) Size() (n int) {
	var l int
	_ = l
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if len(m.Attachments) > 0 {
		for _, e := range m.Attachments {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	return n
}

func (m *MailBody_AttachmentBody) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovMail(uint64(m.Index))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *Result) Size() (n int) {
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *SendRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *SendResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.MailId)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *BroadcastRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *BroadcastResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.MailId)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *GetMailCountRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.FromTime != 0 {
		n += 1 + sovMail(uint64(m.FromTime))
	}
	return n
}

func (m *GetMailCountResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovMail(uint64(m.Total))
	}
	if m.Read != 0 {
		n += 1 + sovMail(uint64(m.Read))
	}
	return n
}

func (m *ListRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovMail(uint64(m.Limit))
	}
	if m.Ascend {
		n += 2
	}
	if m.IsBroadcast {
		n += 2
	}
	return n
}

func (m *ListRequest_TimeAndID) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovMail(uint64(m.Time))
	}
	l = len(m.MailId)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MailHeaderWithID) Size() (n int) {
	var l int
	_ = l
	l = len(m.MailId)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *ListResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if len(m.Mails) > 0 {
		for _, e := range m.Mails {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	return n
}

func (m *MailIndex) Size() (n int) {
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.IsBroadcast {
		n += 2
	}
	l = len(m.MailId)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	var l int
	_ = l
	if m.MailIndex != nil {
		l = m.MailIndex.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *GetResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *DeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.MailIndex != nil {
		l = m.MailIndex.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *DeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MarkAsReadRequest) Size() (n int) {
	var l int
	_ = l
	if m.MailIndex != nil {
		l = m.MailIndex.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MarkAsReadResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MarkAsUnreadRequest) Size() (n int) {
	var l int
	_ = l
	if m.MailIndex != nil {
		l = m.MailIndex.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MarkAsUnreadResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MarkAttachmentsAsReceivedRequest) Size() (n int) {
	var l int
	_ = l
	if m.MailIndex != nil {
		l = m.MailIndex.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MarkAttachmentsAsReceivedResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.CheckFailed {
		n += 2
	}
	return n
}

func (m *SetCustomDataRequest) Size() (n int) {
	var l int
	_ = l
	if m.MailIndex != nil {
		l = m.MailIndex.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *SetCustomDataResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *SubscribeRequest) Size() (n int) {
	var l int
	_ = l
	if m.IsSubscribe {
		n += 2
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *NewMailNotification) Size() (n int) {
	var l int
	_ = l
	if m.OBSOLETEIsBroadcast {
		n += 2
	}
	if len(m.OBSOLETEToList) > 0 {
		for _, b := range m.OBSOLETEToList {
			l = len(b)
			n += 1 + l + sovMail(uint64(l))
		}
	}
	if len(m.BroadcastMails) > 0 {
		for _, e := range m.BroadcastMails {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	if len(m.UserMails) > 0 {
		for _, e := range m.UserMails {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	return n
}

func sovMail(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMail(x uint64) (n int) {
	return sovMail(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MailHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From[:0], dAtA[iNdEx:postIndex]...)
			if m.From == nil {
				m.From = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromNick", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromNick = append(m.FromNick[:0], dAtA[iNdEx:postIndex]...)
			if m.FromNick == nil {
				m.FromNick = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToNick", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToNick = append(m.ToNick[:0], dAtA[iNdEx:postIndex]...)
			if m.ToNick == nil {
				m.ToNick = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = append(m.Title[:0], dAtA[iNdEx:postIndex]...)
			if m.Title == nil {
				m.Title = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Brief", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Brief = append(m.Brief[:0], dAtA[iNdEx:postIndex]...)
			if m.Brief == nil {
				m.Brief = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyLen", wireType)
			}
			m.BodyLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BodyLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attachments = append(m.Attachments, &MailHeader_AttachmentBrief{})
			if err := m.Attachments[len(m.Attachments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &MailHeader_Time{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &MailHeader_Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailHeader_AttachmentBrief) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttachmentBrief: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttachmentBrief: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Brief", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Brief = append(m.Brief[:0], dAtA[iNdEx:postIndex]...)
			if m.Brief == nil {
				m.Brief = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = append(m.Item[:0], dAtA[iNdEx:postIndex]...)
			if m.Item == nil {
				m.Item = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailHeader_Time) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Time: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Time: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
			}
			m.Send = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Send |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			m.Expire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expire |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailHeader_Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Read = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentsReceived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AttachmentsReceived = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = append(m.CustomData[:0], dAtA[iNdEx:postIndex]...)
			if m.CustomData == nil {
				m.CustomData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attachments = append(m.Attachments, &MailBody_AttachmentBody{})
			if err := m.Attachments[len(m.Attachments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailBody_AttachmentBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttachmentBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttachmentBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MailHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &MailBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailId = append(m.MailId[:0], dAtA[iNdEx:postIndex]...)
			if m.MailId == nil {
				m.MailId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcastRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MailHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &MailBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcastResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailId = append(m.MailId[:0], dAtA[iNdEx:postIndex]...)
			if m.MailId == nil {
				m.MailId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMailCountRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMailCountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMailCountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromTime", wireType)
			}
			m.FromTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMailCountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMailCountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMailCountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			m.Read = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Read |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &ListRequest_TimeAndID{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &ListRequest_TimeAndID{}
			}
			if err := m.End.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ascend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ascend = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBroadcast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBroadcast = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRequest_TimeAndID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeAndID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeAndID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailId = append(m.MailId[:0], dAtA[iNdEx:postIndex]...)
			if m.MailId == nil {
				m.MailId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailHeaderWithID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailHeaderWithID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailHeaderWithID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailId = append(m.MailId[:0], dAtA[iNdEx:postIndex]...)
			if m.MailId == nil {
				m.MailId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MailHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mails = append(m.Mails, &MailHeaderWithID{})
			if err := m.Mails[len(m.Mails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBroadcast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBroadcast = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailId = append(m.MailId[:0], dAtA[iNdEx:postIndex]...)
			if m.MailId == nil {
				m.MailId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailIndex == nil {
				m.MailIndex = &MailIndex{}
			}
			if err := m.MailIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &MailBody{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailIndex == nil {
				m.MailIndex = &MailIndex{}
			}
			if err := m.MailIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkAsReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkAsReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkAsReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailIndex == nil {
				m.MailIndex = &MailIndex{}
			}
			if err := m.MailIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkAsReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkAsReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkAsReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkAsUnreadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkAsUnreadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkAsUnreadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailIndex == nil {
				m.MailIndex = &MailIndex{}
			}
			if err := m.MailIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkAsUnreadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkAsUnreadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkAsUnreadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkAttachmentsAsReceivedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkAttachmentsAsReceivedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkAttachmentsAsReceivedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailIndex == nil {
				m.MailIndex = &MailIndex{}
			}
			if err := m.MailIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkAttachmentsAsReceivedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkAttachmentsAsReceivedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkAttachmentsAsReceivedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckFailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckFailed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCustomDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCustomDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCustomDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailIndex == nil {
				m.MailIndex = &MailIndex{}
			}
			if err := m.MailIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = append(m.CustomData[:0], dAtA[iNdEx:postIndex]...)
			if m.CustomData == nil {
				m.CustomData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCustomDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCustomDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCustomDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &Result{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSubscribe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSubscribe = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewMailNotification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewMailNotification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewMailNotification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OBSOLETEIsBroadcast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OBSOLETEIsBroadcast = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OBSOLETEToList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OBSOLETEToList = append(m.OBSOLETEToList, make([]byte, postIndex-iNdEx))
			copy(m.OBSOLETEToList[len(m.OBSOLETEToList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BroadcastMails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BroadcastMails = append(m.BroadcastMails, &MailHeaderWithID{})
			if err := m.BroadcastMails[len(m.BroadcastMails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserMails = append(m.UserMails, &MailHeaderWithID{})
			if err := m.UserMails[len(m.UserMails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMail(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMail
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMail
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMail
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMail
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMail
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMail(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMail = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMail   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("pb/mail.proto", fileDescriptor_mail_651a9a4d896d6f04) }

var fileDescriptor_mail_651a9a4d896d6f04 = []byte{
	// 1296 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4b, 0x6f, 0xdb, 0x46,
	0x10, 0x36, 0x29, 0x59, 0x91, 0x86, 0x92, 0xec, 0xac, 0xed, 0x44, 0x66, 0x00, 0x57, 0x21, 0xfa,
	0x10, 0x9a, 0xc6, 0x69, 0x94, 0x1e, 0x02, 0x17, 0x06, 0xea, 0x47, 0xe2, 0x1a, 0x4d, 0x9c, 0x60,
	0x95, 0x22, 0x40, 0x51, 0x54, 0xa0, 0xc4, 0x35, 0xbc, 0xb1, 0x44, 0xaa, 0xe4, 0x2a, 0x4d, 0x6e,
	0x3d, 0xf5, 0xdc, 0x6b, 0xff, 0x50, 0xd1, 0x63, 0x7f, 0x42, 0x91, 0x1e, 0x7a, 0xed, 0x4f, 0x28,
	0x66, 0x96, 0xa4, 0x28, 0x5a, 0xb6, 0x2b, 0x23, 0x27, 0xed, 0xbc, 0x67, 0xe7, 0xf1, 0x2d, 0x05,
	0xb5, 0x51, 0xef, 0xde, 0xd0, 0x95, 0x83, 0xcd, 0x51, 0x18, 0xa8, 0x80, 0x99, 0xa3, 0x9e, 0xf3,
	0x6f, 0x11, 0xe0, 0xa9, 0x2b, 0x07, 0x5f, 0x0b, 0xd7, 0x13, 0x21, 0x63, 0x50, 0x3c, 0x0e, 0x83,
	0x61, 0xc3, 0x68, 0x1a, 0xad, 0x2a, 0xa7, 0x33, 0xbb, 0x05, 0x15, 0xfc, 0xed, 0xfa, 0xb2, 0x7f,
	0xda, 0x30, 0x49, 0x50, 0x46, 0xc6, 0x91, 0xec, 0x9f, 0xb2, 0x3a, 0x98, 0x2a, 0x68, 0x14, 0x88,
	0x6b, 0xaa, 0x80, 0xdd, 0x84, 0x6b, 0x2a, 0xd0, 0xaa, 0x45, 0x62, 0x96, 0x54, 0x40, 0x8a, 0xab,
	0xb0, 0xa8, 0xa4, 0x1a, 0x88, 0xc6, 0x22, 0xb1, 0x35, 0x81, 0xdc, 0x5e, 0x28, 0xc5, 0x71, 0xa3,
	0xa4, 0xb9, 0x44, 0xb0, 0x75, 0x28, 0xf7, 0x02, 0xef, 0x6d, 0x77, 0x20, 0xfc, 0xc6, 0xb5, 0xa6,
	0xd1, 0xaa, 0xf1, 0x6b, 0x48, 0x3f, 0x11, 0x3e, 0xfb, 0x0a, 0x2c, 0x57, 0x29, 0xb7, 0x7f, 0x32,
	0x14, 0xbe, 0x8a, 0x1a, 0xe5, 0x66, 0xa1, 0x65, 0xb5, 0x37, 0x36, 0x47, 0xbd, 0xcd, 0xc9, 0x2d,
	0x36, 0x77, 0x52, 0x8d, 0x5d, 0xf4, 0xc7, 0xb3, 0x26, 0xec, 0x13, 0x28, 0x2a, 0x39, 0x14, 0x8d,
	0x4a, 0xd3, 0x68, 0x59, 0xed, 0x95, 0x9c, 0xe9, 0x0b, 0x39, 0x14, 0x9c, 0x14, 0xd8, 0x5d, 0x28,
	0x45, 0xca, 0x55, 0xe3, 0xa8, 0x01, 0xa4, 0xba, 0x96, 0x53, 0xed, 0x90, 0x90, 0xc7, 0x4a, 0xf6,
	0xcf, 0x06, 0x2c, 0xe5, 0x02, 0xe3, 0xf5, 0xa4, 0xef, 0x89, 0x37, 0x54, 0xcf, 0x1a, 0xd7, 0xc4,
	0xe4, 0xd2, 0x66, 0xf6, 0xd2, 0x0c, 0x8a, 0x52, 0x89, 0x61, 0x5c, 0x4b, 0x3a, 0xa3, 0x66, 0x3f,
	0x18, 0xfb, 0x8a, 0x6a, 0x59, 0xe3, 0x9a, 0xc0, 0x1a, 0xa3, 0xb4, 0x2b, 0x3d, 0x2a, 0x66, 0x91,
	0x97, 0x90, 0x3c, 0xf4, 0xec, 0x36, 0x14, 0x31, 0x7f, 0x74, 0x15, 0x09, 0xdf, 0xa3, 0xa8, 0x05,
	0x4e, 0x67, 0x76, 0x03, 0x4a, 0xe2, 0xcd, 0x48, 0x86, 0x82, 0xa2, 0x16, 0x78, 0x4c, 0xd9, 0x23,
	0x28, 0xe9, 0x8b, 0xa0, 0x55, 0x28, 0x5c, 0x6d, 0x55, 0xe6, 0x74, 0x66, 0xf7, 0x61, 0x35, 0x53,
	0xbb, 0x6e, 0x28, 0xfa, 0x42, 0xbe, 0x16, 0x1e, 0xf9, 0x28, 0xf3, 0x95, 0x8c, 0x8c, 0xc7, 0x22,
	0xf6, 0x01, 0x58, 0xfd, 0x71, 0xa4, 0x82, 0x61, 0xd7, 0x73, 0x95, 0x1b, 0x5f, 0x07, 0x34, 0x6b,
	0xdf, 0x55, 0xae, 0xf3, 0x9b, 0x01, 0x65, 0x2c, 0xe3, 0x6e, 0xe0, 0xbd, 0xc5, 0xa0, 0xd8, 0xda,
	0x64, 0xe0, 0xf0, 0xcc, 0xb6, 0xa7, 0x7b, 0x6c, 0x52, 0x8f, 0x6f, 0x25, 0xd5, 0x47, 0xb3, 0x6c,
	0x87, 0x03, 0xef, 0xed, 0x54, 0x83, 0xed, 0x2d, 0xa8, 0x4f, 0x8b, 0xcf, 0x69, 0x43, 0x12, 0xda,
	0x9c, 0x84, 0x76, 0x36, 0xa1, 0xc4, 0x45, 0x34, 0x1e, 0x28, 0x1c, 0xec, 0xe0, 0x34, 0xae, 0x85,
	0x19, 0xd0, 0xfc, 0x8a, 0x30, 0x0c, 0x42, 0x52, 0xaf, 0x70, 0x4d, 0x38, 0x2f, 0xc1, 0xea, 0x08,
	0xdf, 0xe3, 0xe2, 0xc7, 0xb1, 0x88, 0x14, 0xfb, 0x18, 0x4a, 0x27, 0x34, 0x1c, 0x64, 0x68, 0xb5,
	0xeb, 0xd3, 0x23, 0xc3, 0x63, 0x29, 0x6b, 0x66, 0x42, 0x5b, 0xed, 0x6a, 0xf6, 0x6a, 0x71, 0x22,
	0xdf, 0x40, 0x55, 0x3b, 0x8e, 0x46, 0x81, 0x1f, 0x09, 0xe6, 0x40, 0x29, 0xa4, 0xc4, 0x62, 0xcf,
	0x80, 0x36, 0x3a, 0x55, 0x1e, 0x4b, 0x70, 0x2e, 0x70, 0xbb, 0x71, 0x2e, 0x74, 0xd5, 0x4b, 0x48,
	0x1e, 0x7a, 0xce, 0xf7, 0xb0, 0xbc, 0x1b, 0x06, 0xae, 0xd7, 0x77, 0x23, 0xf5, 0xfe, 0x53, 0x7d,
	0x0e, 0xd7, 0x33, 0xde, 0xdf, 0x47, 0xbe, 0xbb, 0xb0, 0x72, 0x20, 0x14, 0x86, 0xd9, 0xc3, 0x81,
	0x4f, 0x52, 0xd6, 0x58, 0x63, 0xa4, 0x58, 0x93, 0x00, 0x13, 0xad, 0xb3, 0x9e, 0x6a, 0x02, 0x26,
	0xdc, 0x01, 0xc7, 0x83, 0xd5, 0x69, 0x1f, 0x73, 0x24, 0x86, 0x58, 0x15, 0x28, 0x77, 0x40, 0x4e,
	0x6b, 0x5c, 0x13, 0xe9, 0x7e, 0x14, 0x88, 0x49, 0x67, 0xe7, 0x17, 0x13, 0xac, 0x27, 0x32, 0x3a,
	0x37, 0xc5, 0x7b, 0xb0, 0x18, 0x29, 0x37, 0x54, 0x71, 0xf9, 0xd6, 0x31, 0x58, 0x46, 0x9f, 0xe0,
	0x66, 0xc7, 0xf7, 0x0e, 0xf7, 0xb9, 0xd6, 0x63, 0x77, 0xa0, 0x80, 0x9b, 0x5b, 0xb8, 0x4c, 0x1d,
	0xb5, 0x30, 0xcf, 0x81, 0x1c, 0xca, 0x14, 0x1e, 0x88, 0xc0, 0x4d, 0x77, 0xa3, 0x3e, 0x7a, 0x59,
	0xa4, 0xe9, 0x8d, 0x29, 0x76, 0x1b, 0xaa, 0x32, 0xea, 0xf6, 0x92, 0x56, 0x11, 0xe4, 0x96, 0xb9,
	0x25, 0xa3, 0xb4, 0x7b, 0xf6, 0x43, 0xa8, 0xa4, 0x21, 0xf0, 0xbe, 0x54, 0xd9, 0x18, 0x45, 0x08,
	0x13, 0x33, 0x2d, 0x33, 0xa7, 0x5a, 0xd6, 0x81, 0xe5, 0xc9, 0xf0, 0xbc, 0x94, 0xea, 0xe4, 0x70,
	0x3f, 0xab, 0x6c, 0x64, 0x95, 0x33, 0xb3, 0x67, 0x5e, 0x34, 0x7b, 0xce, 0x0f, 0x50, 0xd5, 0xb7,
	0x9f, 0xa3, 0x77, 0x9f, 0xc2, 0x22, 0x46, 0x49, 0x60, 0x63, 0x75, 0xda, 0xb5, 0xce, 0x8c, 0x6b,
	0x15, 0xe7, 0x25, 0x54, 0x50, 0x74, 0x48, 0x70, 0x90, 0x6f, 0x5d, 0xbe, 0x5c, 0xe6, 0x99, 0x72,
	0x9d, 0x3f, 0xc0, 0x5b, 0x00, 0x07, 0x22, 0x1d, 0x8a, 0xcf, 0x00, 0xb4, 0x5a, 0x8a, 0x41, 0x56,
	0xbb, 0x96, 0xe4, 0x45, 0xc1, 0x79, 0x65, 0x98, 0x1c, 0x9d, 0x0e, 0x58, 0x64, 0x3b, 0xc7, 0x9d,
	0x2f, 0xdf, 0xd1, 0x6d, 0xa8, 0xed, 0x8b, 0x81, 0x50, 0xe2, 0x6a, 0x39, 0x7d, 0x01, 0xf5, 0xc4,
	0xfc, 0xff, 0xa7, 0xe5, 0xec, 0xc0, 0xf5, 0xa7, 0x6e, 0x78, 0xba, 0x13, 0x71, 0xe1, 0x7a, 0x57,
	0x0b, 0xfc, 0x10, 0x58, 0xd6, 0xc5, 0x1c, 0xc1, 0xf7, 0x60, 0x45, 0x5b, 0x7e, 0xeb, 0x87, 0x57,
	0x0e, 0xbf, 0x05, 0xab, 0xd3, 0x4e, 0xe6, 0x48, 0xe0, 0x39, 0x34, 0xc9, 0x76, 0xf2, 0x32, 0xed,
	0xa4, 0x8f, 0xe4, 0xd5, 0xb2, 0x79, 0x05, 0xb7, 0x2f, 0xf0, 0x38, 0xc7, 0xbc, 0xdc, 0x86, 0x6a,
	0xff, 0x44, 0xf4, 0x4f, 0xbb, 0xc7, 0xae, 0x1c, 0xa4, 0xaf, 0xb9, 0x45, 0xbc, 0xc7, 0xc4, 0x72,
	0x04, 0xac, 0x76, 0x84, 0xda, 0x4b, 0x5f, 0xed, 0x2b, 0x65, 0x9c, 0xff, 0x16, 0x30, 0xcf, 0x7c,
	0x0b, 0x7c, 0x09, 0x6b, 0xb9, 0x30, 0x73, 0x54, 0xf8, 0x11, 0x2c, 0x77, 0xc6, 0xbd, 0xa8, 0x1f,
	0xca, 0x5e, 0x3a, 0xd7, 0x7a, 0x6b, 0xa3, 0x84, 0x1d, 0x3f, 0xe0, 0x96, 0x8c, 0x52, 0xcd, 0x78,
	0xd1, 0xcd, 0x64, 0xd1, 0x9d, 0x7f, 0x0c, 0x58, 0x39, 0x12, 0x3f, 0xe1, 0x05, 0x8e, 0x02, 0x25,
	0x8f, 0x65, 0xdf, 0x55, 0x32, 0xf0, 0x59, 0x1b, 0xd6, 0x9e, 0xed, 0x76, 0x9e, 0x3d, 0x79, 0xf4,
	0xe2, 0x51, 0x77, 0x0a, 0x09, 0xb4, 0xcf, 0x95, 0x44, 0x78, 0x98, 0x41, 0x84, 0x16, 0x2c, 0xa7,
	0x36, 0x2a, 0xe8, 0x0e, 0x24, 0x01, 0x47, 0xa1, 0x55, 0xe5, 0xf5, 0x84, 0xff, 0x22, 0x40, 0x4c,
	0x63, 0xdb, 0xb0, 0x94, 0x7a, 0xec, 0x6a, 0xc4, 0x2a, 0x5c, 0x80, 0x58, 0xf5, 0x54, 0x19, 0x45,
	0x11, 0x7b, 0x00, 0x30, 0x8e, 0x44, 0x18, 0x5b, 0x16, 0x2f, 0xb0, 0xac, 0xa0, 0x1e, 0x19, 0xb5,
	0x7f, 0x5f, 0x84, 0x22, 0x9e, 0xd8, 0x1d, 0x28, 0xe2, 0xd7, 0x05, 0x5b, 0x42, 0x8b, 0xcc, 0x07,
	0x8c, 0xbd, 0x3c, 0x61, 0xe8, 0x46, 0x38, 0x0b, 0x6c, 0x0b, 0x2a, 0x93, 0x0b, 0x52, 0x8c, 0xfc,
	0xc7, 0x84, 0xbd, 0x96, 0xe3, 0xa6, 0xb6, 0x7b, 0x50, 0xcd, 0xbe, 0xc2, 0xec, 0x26, 0x2a, 0xce,
	0x78, 0xdb, 0xed, 0xc6, 0x59, 0x41, 0xea, 0xe4, 0x0e, 0x14, 0xa9, 0x64, 0x4b, 0xb9, 0xe7, 0x50,
	0x67, 0x9b, 0x7d, 0x21, 0x9c, 0x05, 0xd6, 0x82, 0xc2, 0x81, 0x50, 0xac, 0x1e, 0xfb, 0x4b, 0x54,
	0x97, 0x52, 0x3a, 0xd5, 0xbc, 0x0f, 0x25, 0x0d, 0x6a, 0xec, 0x3a, 0x0a, 0xa7, 0xf0, 0xd1, 0x66,
	0x59, 0x56, 0x6a, 0xb2, 0x8d, 0x7f, 0x96, 0x12, 0x38, 0x62, 0xf1, 0x1f, 0x82, 0x1c, 0xc2, 0xd9,
	0x37, 0xf2, 0xec, 0x6c, 0x35, 0xb2, 0x70, 0xa2, 0xab, 0x31, 0x03, 0xa5, 0x74, 0x35, 0x66, 0x21,
	0x8f, 0xb3, 0xc0, 0x5e, 0xc1, 0xfa, 0xb9, 0x28, 0xc0, 0x3e, 0x4c, 0x0d, 0x2f, 0x80, 0x1d, 0xfb,
	0xa3, 0x4b, 0xb4, 0xd2, 0x58, 0x8f, 0xa1, 0x36, 0xb5, 0x9e, 0xac, 0xa1, 0xe7, 0xe3, 0x2c, 0x30,
	0xd8, 0xeb, 0x33, 0x24, 0xa9, 0x9f, 0x23, 0xb8, 0x79, 0x20, 0xd4, 0x8c, 0x25, 0x8b, 0xf4, 0x40,
	0xe5, 0xd7, 0xd8, 0xa6, 0xca, 0xcc, 0xd0, 0x77, 0x16, 0x5a, 0xc6, 0xe7, 0xc6, 0x6e, 0xf3, 0x8f,
	0x77, 0x1b, 0xc6, 0x9f, 0xef, 0x36, 0x8c, 0xbf, 0xde, 0x6d, 0x18, 0xbf, 0xfe, 0xbd, 0xb1, 0xf0,
	0x5d, 0x1d, 0x17, 0xe1, 0x6e, 0x24, 0xc2, 0xd7, 0x22, 0xbc, 0x37, 0xea, 0xf5, 0x4a, 0xf4, 0x17,
	0xf7, 0xc1, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xb8, 0x30, 0xae, 0x1d, 0xf3, 0x0e, 0x00, 0x00,
}
